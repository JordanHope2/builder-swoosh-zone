-- ========================= COMPANIES ===========================
-- This schema defines tables for storing company profiles.
-- It separates the canonical, clean company data from the raw scraped data.

-- Drop tables if they exist to ensure a clean setup.
DROP TABLE IF EXISTS "public"."companies_scraped_raw_data" CASCADE;
DROP TABLE IF EXISTS "public"."companies" CASCADE;


-- 1) Canonical Companies Table
-- This table holds the clean, authoritative data for each company.
CREATE TABLE "public"."companies" (
    "id" uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
    "name" text NOT NULL,
    "website_url" text,
    "location" text,
    "address" text,
    "company_size" integer,
    "phone" text,
    "industry" text,
    "legal_entity_type" text,
    "zefix_uid" text UNIQUE, -- Unique identifier from the Zefix registry
    "created_at" timestamp with time zone NOT NULL DEFAULT now(),
    "updated_at" timestamp with time zone NOT NULL DEFAULT now()
);

-- Add comments for clarity
COMMENT ON TABLE "public"."companies" IS 'Stores canonical, clean profiles for companies.';
COMMENT ON COLUMN "public"."companies"."zefix_uid" IS 'The unique ID from the Swiss Zefix commercial registry. Used for deduplication.';


-- 2) Raw Scraped Data Table
-- This table stores the raw JSON response from every scrape for auditing and reprocessing.
CREATE TABLE "public"."companies_scraped_raw_data" (
    "id" bigint NOT NULL generated by default as identity,
    "company_id" uuid NOT NULL,
    "source" text NOT NULL, -- e.g., 'zefix', 'linkedin', 'adzuna'
    "source_id" text,      -- The ID from the source platform, if available
    "raw_data" jsonb NOT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT now(),

    CONSTRAINT "companies_scraped_raw_data_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "companies_scraped_raw_data_company_id_fkey" FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE
);

-- Add comments for clarity
COMMENT ON TABLE "public"."companies_scraped_raw_data" IS 'Stores raw JSON data from various sources for each company.';
COMMENT ON COLUMN "public"."companies_scraped_raw_data"."company_id" IS 'A foreign key to the canonical company profile.';


-- 3) Trigger for updated_at timestamp
-- This function and trigger automatically update the `updated_at` field on the `companies` table.
CREATE OR REPLACE FUNCTION "public"."handle_companies_updated_at"()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER "on_companies_update_set_updated_at"
BEFORE UPDATE ON "public"."companies"
FOR EACH ROW
EXECUTE PROCEDURE "public"."handle_companies_updated_at"();


-- 4) RLS (Row Level Security) Policies
-- Enable RLS for the new tables.
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies_scraped_raw_data ENABLE ROW LEVEL SECURITY;

-- For now, we will allow public read access, but restrict write access.
-- These can be adjusted later to match the application's security model.
CREATE POLICY "companies_read_all" ON public.companies FOR SELECT USING (true);
CREATE POLICY "companies_scraped_raw_data_read_all" ON public.companies_scraped_raw_data FOR SELECT USING (true);

-- In a real application, you would add INSERT/UPDATE/DELETE policies
-- restricted to specific roles (e.g., service_role or admin).
-- Example: CREATE POLICY "companies_admin_write" ON public.companies FOR ALL USING ( (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin' );


-- 5) Notify PostgREST to reload its schema cache
NOTIFY pgrst, 'reload schema';
